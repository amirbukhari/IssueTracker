import { HashOf } from './object';
/**
 * Interface used to identify a mappable object. According to most sources, this qualifies as
 * a "functor", but want to verify.
 */
export interface IMappableObject {
    map: (fn: (value: any, index: number, array: any[]) => any, thisArg?: any) => any[];
}
/**
 * Determines if the provided object or the key of the provided object is a function.
 * If only `x` is provided, then it will be the target. If both `x` and `key` are provided, `x[key]` is the target.
 * @param x
 * @param key
 */
export declare const isFunction: (x: any) => x is Function;
/**
 * Returns a curried version of the provided function.
 * (Note: This will probably mess with your IDE's ability to provide intellisense)
 *
 * [Borrowed from Mostly Adequate Guide](https://mostly-adequate.gitbooks.io/mostly-adequate-guide/content/appendix_a.html#curry)
 *
 * Signature: curry :: ((a, b, ...) => c) => a => b => ... => c
 * @param fn - Function to curry
 */
export declare const curry: (fn: Function) => (...args: any[]) => any;
/**
 * Like `map()`, but awaitable. This way you can ensure mapped async functions have resolved, if desired.
 * @param list
 * @param fn
 */
export declare const mapAsync: <T, U>(list: T[], fn: (value: T, index: number, array: T[]) => Promise<U>) => Promise<U[]>;
/**
 * (Don't use this - deprecation incoming quickly) Provides an English-esque interface for getting a key from an object with a default value.
 * @param key
 * @param defaultValue
 * @deprecated Hindsight being what it is, this isn't the best. Doesn't really match the rest of the methodology throughout this project.
 */
export declare const take: <T>(key: string, defaultValue?: T | undefined) => {
    from: (object: HashOf<T>) => T | undefined;
};
/**
 * Returns the value given. Intended for used in some branching expressions as a means of ensuring
 * we always return a function value to reduce complexity otherwise introduced with null checking, etc.
 * @param id
 */
export declare const identity: <T>(id: T) => T;
/**
 * Partially apply a function by filling in any number of its arguments.
 * Note: We will often lose some of typescript's intellisense when using `partial()`
 * @param fn The function to partially apply
 * @param args Some arguments. Does not have to be all of the arguments needed for the base function.
 */
export declare const partial: (fn: CallableFunction, ...args: any[]) => (...newArgs: any[]) => any;
/**
 * Wraps a function that normally accepts a single array as an argument so that elements can be provided as individual parameters
 * @param fn The function to wrap
 */
export declare const spreadArgs: <T>(fn: (arg: T[]) => T) => (...args: T[]) => T;
/**
 * Wraps a function that normally accepts multiple parameters such that the elements can be provided as an array.
 * @param fn The function to wrap.
 */
export declare const argsAsArray: <T>(fn: (...args: T[]) => T) => (arg: T[]) => T;
/**
 * Reverses the order of arguments in a function call. Helpful for many 'functional programming' tasks.
 * @param fn The function to reverse arguments for.
 */
export declare const reverseArgs: (fn: CallableFunction) => (...args: any[]) => any;
/**
 * Functional style conditional
 * @param condition An expression representing the query
 * @param truePath A function to apply when `condition` resolves to true
 * @param falsePath A function to apply when `condition` resolves to false
 */
export declare const branch: <T>(condition: boolean, truePath: (x: T) => any, falsePath?: ((x: T) => any) | undefined) => (x: T) => any;
/**
 * Functional style try catch expression
 * @param tryPath A function which contains the initial code that will be attempted
 * @param catchPath A function which handles errors if they occur in `tryPath`
 * @param finallyPath A function that is run after try or finally.
 */
export declare const tryCatch: <T>(tryPath: (x: T) => any, catchPath: (x: T, error?: any) => any, finallyPath: (x: T, results: {
    tryResult: any;
    catchResult: any;
}) => any) => (x: T) => void;
/**
 * Wrap a function so that it will only run at most `times` times when called from the resulting wrapper.
 *
 * Note:
 *   Contrary to this library's overall design philosophy, by its nature, `maxTimes()` often results in a
 *   function which causes side effects.
 *
 * Warning:
 *   Use cautiously. Calling the resulting function more than the allotted number of times will return `null`.
 *
 * @param times - Number of times to allow this function to run
 * @param fn - Function to wrap
 * @param context - An optional context to provide `this` for the enclosed function.
 */
export declare const maxTimes: <T extends (...args: any[]) => any>(times: number, fn: T, context?: any) => T;
/**
 * Convenience method providing a wrapper that can only run an enclosed function once. Delegates to `maxTimes`
 * Warning:
 *   Use cautiously. Calling the resulting function more than one time will return `null`.
 * @param fn - Function to wrap
 * @param context - An optional context to provide `this` for the enclosed function.
 */
export declare const maxOnce: <T extends (...args: any[]) => any>(fn: T, context?: any) => T;
export declare const repeat: (repeatTimes: number, fn: (index: number, ...fnArgs: any[]) => void, ...args: any[]) => void;
export declare const repeatWhile: (repeatCondition: () => boolean, fn: (...fnArgs: any[]) => void, ...args: any[]) => void;
export declare const repeatAsync: (repeatTimes: number, fn: (...args: any[]) => Promise<any>, ...args: any[]) => Promise<void>;
export declare const repeatWhileAsync: (repeatCondition: () => boolean, fn: (...args: any[]) => Promise<any>, ...args: any[]) => Promise<void>;
export declare const repeatWithBreak: (repeatTimes: number, fn: (i: number, done: CallableFunction, ...fnargs: any[]) => any, ...args: any[]) => void;
export declare const repeatAsyncWithBreak: (repeatTimes: number, fn: (i: number, done: CallableFunction, ...fnargs: any[]) => Promise<any>, ...args: any[]) => Promise<void>;
export declare const selectBranch: <T extends CallableFunction>(key: string, callMap: HashOf<T>, ...args: any[]) => Promise<void>;
//# sourceMappingURL=functional.d.ts.map