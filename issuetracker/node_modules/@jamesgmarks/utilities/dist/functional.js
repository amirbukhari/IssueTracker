"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const object_1 = require("./object");
const array_1 = require("./array");
/**
 * Determines if the provided object or the key of the provided object is a function.
 * If only `x` is provided, then it will be the target. If both `x` and `key` are provided, `x[key]` is the target.
 * @param x
 * @param key
 */
exports.isFunction = (x) => (typeof x === 'function');
// TODO: evaluate `either()`, `maybe()` etc
// export function either<T1 extends undefined, T2>(a: T1, b: T2): T2;
// export function either<T1 extends any, T2>(a: T1, b: T2): T1;
// export function either <T1 extends any, T2>(a: T1, b: T2): T1 | T2 {
//   return (a || b);
// }
// export const maybe = <T>(a: T): T | null => either(a, null);
/**
 * Returns a curried version of the provided function.
 * (Note: This will probably mess with your IDE's ability to provide intellisense)
 *
 * [Borrowed from Mostly Adequate Guide](https://mostly-adequate.gitbooks.io/mostly-adequate-guide/content/appendix_a.html#curry)
 *
 * Signature: curry :: ((a, b, ...) => c) => a => b => ... => c
 * @param fn - Function to curry
 */
exports.curry = (fn) => {
    const arity = fn.length;
    return function $curry(...args) {
        if (args.length < arity) {
            return $curry.bind(null, ...args);
        }
        return fn.call(null, ...args);
    };
};
/**
 * Like `map()`, but awaitable. This way you can ensure mapped async functions have resolved, if desired.
 * @param list
 * @param fn
 */
exports.mapAsync = (list, fn) => __awaiter(void 0, void 0, void 0, function* () { return Promise.all(list.map((id, ix, ar) => __awaiter(void 0, void 0, void 0, function* () { return fn(id, ix, ar); }))); });
/**
 * (Don't use this - deprecation incoming quickly) Provides an English-esque interface for getting a key from an object with a default value.
 * @param key
 * @param defaultValue
 * @deprecated Hindsight being what it is, this isn't the best. Doesn't really match the rest of the methodology throughout this project.
 */
exports.take = (key, defaultValue) => ({
    from: (object) => (object_1.hasKey(object, key) ? object[key] : defaultValue),
});
/**
 * Returns the value given. Intended for used in some branching expressions as a means of ensuring
 * we always return a function value to reduce complexity otherwise introduced with null checking, etc.
 * @param id
 */
exports.identity = (id) => id;
/**
 * Partially apply a function by filling in any number of its arguments.
 * Note: We will often lose some of typescript's intellisense when using `partial()`
 * @param fn The function to partially apply
 * @param args Some arguments. Does not have to be all of the arguments needed for the base function.
 */
exports.partial = (fn, ...args) => (...newArgs) => fn(...args, ...newArgs);
/**
 * Wraps a function that normally accepts a single array as an argument so that elements can be provided as individual parameters
 * @param fn The function to wrap
 */
exports.spreadArgs = (fn) => (...args) => fn(args);
/**
 * Wraps a function that normally accepts multiple parameters such that the elements can be provided as an array.
 * @param fn The function to wrap.
 */
exports.argsAsArray = (fn) => (arg) => fn(...arg);
/**
 * Reverses the order of arguments in a function call. Helpful for many 'functional programming' tasks.
 * @param fn The function to reverse arguments for.
 */
exports.reverseArgs = (fn) => (...args) => fn(...array_1.reverse(args));
/**
 * Functional style conditional
 * @param condition An expression representing the query
 * @param truePath A function to apply when `condition` resolves to true
 * @param falsePath A function to apply when `condition` resolves to false
 */
exports.branch = (condition, truePath, falsePath) => (x) => (
// eslint-disable-next-line no-nested-ternary
condition ? truePath(x) : (falsePath ? falsePath(x) : exports.identity(x)));
/**
 * Functional style try catch expression
 * @param tryPath A function which contains the initial code that will be attempted
 * @param catchPath A function which handles errors if they occur in `tryPath`
 * @param finallyPath A function that is run after try or finally.
 */
exports.tryCatch = (tryPath, catchPath, finallyPath) => (x) => {
    let tryResult = null;
    let catchResult = null;
    try {
        tryResult = tryPath(x);
    }
    catch (error) {
        catchResult = catchPath(x, error);
    }
    finally {
        finallyPath(x, { tryResult, catchResult });
    }
};
/**
 * Wrap a function so that it will only run at most `times` times when called from the resulting wrapper.
 *
 * Note:
 *   Contrary to this library's overall design philosophy, by its nature, `maxTimes()` often results in a
 *   function which causes side effects.
 *
 * Warning:
 *   Use cautiously. Calling the resulting function more than the allotted number of times will return `null`.
 *
 * @param times - Number of times to allow this function to run
 * @param fn - Function to wrap
 * @param context - An optional context to provide `this` for the enclosed function.
 */
exports.maxTimes = (times, fn, context) => {
    let ranTimes = 0;
    return function someFunction(...args) {
        if (ranTimes >= times)
            return null;
        ranTimes += 1;
        return fn.apply(context || this, args);
    };
};
/**
 * Convenience method providing a wrapper that can only run an enclosed function once. Delegates to `maxTimes`
 * Warning:
 *   Use cautiously. Calling the resulting function more than one time will return `null`.
 * @param fn - Function to wrap
 * @param context - An optional context to provide `this` for the enclosed function.
 */
exports.maxOnce = (fn, context) => exports.maxTimes(1, fn, context);
exports.repeat = (repeatTimes, fn, ...args) => {
    for (let i = 0; i < repeatTimes; i++) {
        fn(i, ...args);
    }
};
exports.repeatWhile = (repeatCondition, fn, ...args) => {
    while (repeatCondition()) {
        fn(...args);
    }
};
exports.repeatAsync = (repeatTimes, fn, ...args) => __awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line no-await-in-loop
    for (let i = 0; i < repeatTimes; i++) {
        yield fn(i, ...args);
    }
});
exports.repeatWhileAsync = (repeatCondition, fn, ...args) => __awaiter(void 0, void 0, void 0, function* () {
    // eslint-disable-next-line no-await-in-loop
    while (repeatCondition()) {
        yield fn(...args);
    }
});
exports.repeatWithBreak = (repeatTimes, fn, ...args) => {
    let isDone = false;
    for (let i = 0; i < repeatTimes; i++) {
        // eslint-disable-next-line no-loop-func
        fn(i, () => { isDone = true; }, ...args);
        if (isDone)
            break;
    }
};
exports.repeatAsyncWithBreak = (repeatTimes, fn, ...args) => __awaiter(void 0, void 0, void 0, function* () {
    let isDone = false;
    const setDone = () => { isDone = true; };
    for (let i = 0; i < repeatTimes; i++) {
        // eslint-disable-next-line no-await-in-loop
        yield fn(i, setDone, ...args);
        if (isDone)
            break;
    }
});
exports.selectBranch = (key, callMap, ...args) => __awaiter(void 0, void 0, void 0, function* () {
    (callMap[key] ? callMap[key] : exports.identity)(key, ...args);
});
// const iif = <T>(condition: boolean, value: T, falseValue: T) => (condition ? value : falseValue);
// const select = <T extends string | number, U>(value: T, resultList: HashOf<U>) => (resultList[value]);
//# sourceMappingURL=functional.js.map